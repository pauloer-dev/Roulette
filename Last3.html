<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roulette Mirror Pool (Last 3 Results)</title>
  <style>
    :root { --bg:#0b0f14; --card:#121926; --muted:#9aa4b2; --text:#e6edf3; --ok:#2dd4bf; --warn:#fbbf24; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 980px; margin: 24px auto; padding: 0 16px; }
    h1 { font-size: 22px; margin: 0 0 12px; }
    p { margin: 8px 0; color: var(--muted); line-height: 1.4; }
    .grid { display:grid; grid-template-columns: 1fr; gap: 12px; }
    @media (min-width: 860px) { .grid { grid-template-columns: 1.1fr 0.9fr; } }

    .card { background: var(--card); border: 1px solid rgba(255,255,255,0.06); border-radius: 14px; padding: 14px; }
    .row { display:flex; gap:10px; flex-wrap: wrap; align-items: end; }
    .field { display:flex; flex-direction: column; gap: 6px; }
    label { font-size: 12px; color: var(--muted); }
    input[type="number"]{
      width: 120px; padding: 10px 10px; border-radius: 10px;
      border: 1px solid rgba(255,255,255,0.10); background: rgba(0,0,0,0.20); color: var(--text);
      outline: none;
    }
    input[type="number"]:focus { border-color: rgba(45,212,191,0.6); box-shadow: 0 0 0 3px rgba(45,212,191,0.12); }
    button{
      padding: 10px 12px; border-radius: 10px; border: 1px solid rgba(255,255,255,0.12);
      background: rgba(45,212,191,0.16); color: var(--text); cursor: pointer;
    }
    button:hover{ background: rgba(45,212,191,0.22); }

    .hint { font-size: 12px; color: var(--muted); margin-top: 6px; }
    .err { color: var(--bad); font-size: 13px; margin-top: 8px; }

    table { width:100%; border-collapse: collapse; margin-top: 10px; }
    th, td { text-align:left; padding: 10px 8px; border-bottom: 1px solid rgba(255,255,255,0.06); vertical-align: top; }
    th { color: var(--muted); font-weight: 600; font-size: 12px; }
    td { font-size: 14px; }

    .chips { display:flex; flex-wrap: wrap; gap: 8px; }
    .chip{
      display:inline-flex; align-items:center; gap: 6px;
      padding: 7px 10px; border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.10);
      background: rgba(0,0,0,0.18);
      font-size: 13px;
    }
    .w { font-size: 11px; color: var(--muted); border-left: 1px solid rgba(255,255,255,0.12); padding-left: 6px; }
    .tag { font-size: 11px; color: rgba(255,255,255,0.85); padding: 2px 8px; border-radius: 999px; border:1px solid rgba(255,255,255,0.12); }
    .tag.ok { border-color: rgba(45,212,191,0.35); color: rgba(45,212,191,0.95); }
    .tag.warn { border-color: rgba(251,191,36,0.35); color: rgba(251,191,36,0.95); }

    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .small { font-size: 12px; color: var(--muted); }
    .divider { height: 1px; background: rgba(255,255,255,0.06); margin: 12px 0; }
  </style>
</head>
<body>
  <div class="wrap">
    <h1>Last-3 Mirror Pool (Your Algorithm Only)</h1>
    <p>
      Enter the <b>last three results</b> (0–36). The script builds each result’s <b>mirror series</b> using your rule:
      <span class="mono">lastDigit ↔ lastDigit+5 (mod 10)</span>, across tens, dropping &gt;36.
      Then it merges into one <b>combined mirror pool</b> and shows which pool numbers sit <b>near each other on the European wheel</b>.
    </p>

    <div class="grid">
      <div class="card">
        <div class="row">
          <div class="field">
            <label for="r1">Result #1 (oldest)</label>
            <input id="r1" type="number" min="0" max="36" placeholder="e.g. 31" />
          </div>
          <div class="field">
            <label for="r2">Result #2</label>
            <input id="r2" type="number" min="0" max="36" placeholder="e.g. 36" />
          </div>
          <div class="field">
            <label for="r3">Result #3 (latest)</label>
            <input id="r3" type="number" min="0" max="36" placeholder="e.g. 30" />
          </div>
          <div class="field">
            <label>&nbsp;</label>
            <button id="go">Compute mirror pool</button>
          </div>
        </div>
        <div class="hint">Tip: Press Enter in any box to compute.</div>
        <div id="error" class="err" style="display:none;"></div>

        <div class="divider"></div>

        <div id="bySource"></div>
      </div>

      <div class="card">
        <div>
          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <div>
              <div style="font-weight:700;">Combined mirror pool</div>
              <div class="small">Unique numbers, with weights = how many of the last 3 contributed that number.</div>
            </div>
            <div class="tag ok">Mirror = +5 digit</div>
          </div>

          <div id="pool" style="margin-top:10px;"></div>

          <div class="divider"></div>

          <div style="display:flex; align-items:center; justify-content:space-between; gap:10px; flex-wrap:wrap;">
            <div>
              <div style="font-weight:700;">Wheel-near clusters (European)</div>
              <div class="small">Groups of pool numbers that are adjacent on the wheel (circular).</div>
            </div>
            <div class="tag warn">European wheel</div>
          </div>

          <div id="clusters" style="margin-top:10px;"></div>

          <div class="divider"></div>
          <div class="small">
            Wheel order used (European):<br/>
            <span class="mono" id="wheelOrder"></span>
          </div>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // European wheel order (single-zero)
  const WHEEL = [0, 32, 15, 19, 4, 21, 2, 25, 17, 34, 6, 27, 13, 36, 11, 30, 8, 23, 10, 5, 24, 16, 33, 1, 20, 14, 31, 9, 22, 18, 29, 7, 28, 12, 35, 3, 26];
  const wheelIndex = new Map(WHEEL.map((n, i) => [n, i]));

  const $ = (id) => document.getElementById(id);
  const r1 = $("r1"), r2 = $("r2"), r3 = $("r3");
  const error = $("error");
  const bySource = $("bySource");
  const pool = $("pool");
  const clusters = $("clusters");
  $("wheelOrder").textContent = WHEEL.join(" \u2192 ");

  function showError(msg) {
    error.style.display = msg ? "block" : "none";
    error.textContent = msg || "";
  }

  function isInt(n) { return Number.isInteger(n); }
  function parseVal(inp) {
    const v = inp.value.trim();
    if (v === "") return null;
    const n = Number(v);
    if (!isInt(n)) return NaN;
    return n;
  }

  // YOUR MIRROR RULE: lastDigit + 5 (mod 10), across tens, drop > 36
  function mirrorDigit(d) {
    return (d + 5) % 10;
  }

  function mirrorSeriesForNumber(n) {
    const d = ((n % 10) + 10) % 10;
    const md = mirrorDigit(d);
    const out = [];
    for (let x = 0; x <= 36; x++) {
      if (x % 10 === md) out.push(x);
    }
    return out; // already "drop > 36" because we only iterate to 36
  }

  function formatNums(arr) {
    return arr.slice().sort((a,b)=>a-b).join(", ");
  }

  function computeClustersFromPool(poolSet) {
    // Build list of indices for pool numbers (wheel positions)
    const idxs = [];
    for (const n of poolSet) {
      if (wheelIndex.has(n)) idxs.push(wheelIndex.get(n));
    }
    if (idxs.length === 0) return [];

    idxs.sort((a,b)=>a-b);

    // Group consecutive indices
    const groups = [];
    let current = [idxs[0]];
    for (let i = 1; i < idxs.length; i++) {
      if (idxs[i] === idxs[i-1] + 1) current.push(idxs[i]);
      else { groups.push(current); current = [idxs[i]]; }
    }
    groups.push(current);

    // Merge wrap-around adjacency (end connects to start)
    if (groups.length > 1) {
      const first = groups[0];
      const last = groups[groups.length - 1];
      if (last[last.length - 1] === WHEEL.length - 1 && first[0] === 0) {
        const merged = last.concat(first);
        groups.splice(groups.length - 1, 1);
        groups[0] = merged;
      }
    }

    // Convert indices -> numbers, keep only clusters of size >= 2
    const numGroups = groups
      .map(g => g.map(i => WHEEL[i]))
      .filter(g => g.length >= 2);

    // Sort by size desc, then by earliest wheel index
    numGroups.sort((a,b) => b.length - a.length || wheelIndex.get(a[0]) - wheelIndex.get(b[0]));
    return numGroups;
  }

  function render() {
    showError("");

    const a = parseVal(r1), b = parseVal(r2), c = parseVal(r3);
    const vals = [a,b,c];

    if (vals.some(v => v === null)) { showError("Enter all 3 results (0–36)."); return; }
    if (vals.some(v => Number.isNaN(v))) { showError("Use whole numbers only."); return; }
    if (vals.some(v => v < 0 || v > 36)) { showError("Each result must be between 0 and 36."); return; }

    // Build mirrors per result (last-3 only)
    const results = [a,b,c];
    const perResult = results.map(n => ({ n, mirrors: mirrorSeriesForNumber(n) }));

    // Build combined pool + weights (how many results contributed each number)
    const weight = new Map(); // number -> count
    for (const pr of perResult) {
      const unique = new Set(pr.mirrors); // avoid double-count inside same series (safe anyway)
      for (const x of unique) weight.set(x, (weight.get(x) || 0) + 1);
    }
    const poolSet = new Set(weight.keys());

    // Render by-source table
    let html = `
      <div style="font-weight:700;">Mirror series per result</div>
      <table>
        <thead>
          <tr>
            <th>Result</th>
            <th>Mirror series (by your +5 digit rule)</th>
          </tr>
        </thead>
        <tbody>
    `;
    for (const pr of perResult) {
      html += `
        <tr>
          <td class="mono">${pr.n}</td>
          <td class="mono">${formatNums(pr.mirrors)}</td>
        </tr>
      `;
    }
    html += `</tbody></table>`;
    bySource.innerHTML = html;

    // Render combined pool chips (sorted by weight desc then numeric)
    const combined = Array.from(poolSet).sort((x,y) => (weight.get(y) - weight.get(x)) || (x - y));
    const chips = combined.map(n => {
      const w = weight.get(n);
      const strength = w === 3 ? "ok" : (w === 2 ? "warn" : "");
      const tag = w === 3 ? `<span class="tag ok">x3</span>` : (w === 2 ? `<span class="tag warn">x2</span>` : `<span class="tag">x1</span>`);
      return `<span class="chip mono">${n}<span class="w">${tag}</span></span>`;
    }).join("");

    pool.innerHTML = combined.length
      ? `<div class="chips">${chips}</div><div class="hint">Pool size: <b>${combined.length}</b></div>`
      : `<div class="small">No pool.</div>`;

    // Render wheel-near clusters
    const groups = computeClustersFromPool(poolSet);

    if (groups.length === 0) {
      clusters.innerHTML = `<div class="small">No adjacent clusters found in the pool (on the wheel).</div>`;
    } else {
      const list = groups.map((g, i) => {
        // Show weights next to each number
        const parts = g.map(n => `${n}(x${weight.get(n) || 1})`).join(" \u2192 ");
        return `<div class="chip mono" style="border-color: rgba(255,255,255,0.16); background: rgba(0,0,0,0.22);">
                  #${i+1}&nbsp;&nbsp;${parts}
                </div>`;
      }).join("");

      clusters.innerHTML = `
        <div class="chips">${list}</div>
        <div class="hint">Clusters are runs of pool numbers that sit next to each other on the European wheel (wrap-around included).</div>
      `;
    }
  }

  $("go").addEventListener("click", render);
  [r1,r2,r3].forEach(inp => inp.addEventListener("keydown", (e) => { if (e.key === "Enter") render(); }));

  // Small convenience: if user types, you can auto-update (optional). Kept OFF to avoid surprise.
})();
</script>
</body>
</html>
