<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Roulette Block-Jump Tool</title>
  <style>
    :root {
      --bg: #0b0f14;
      --card: #121824;
      --muted: #8ea0b8;
      --text: #e8eef7;
      --accent: #ff6a3d;
      --ok: #39d98a;
      --border: rgba(255,255,255,.08);
      --shadow: 0 12px 28px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      --radius: 16px;
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: var(--sans);
      background: radial-gradient(1200px 700px at 20% 0%, rgba(255,106,61,.12), transparent 60%),
                  radial-gradient(900px 600px at 100% 30%, rgba(57,217,138,.10), transparent 55%),
                  var(--bg);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      place-items: center;
      padding: 20px;
    }
    .wrap {
      width: min(860px, 100%);
      display: grid;
      gap: 14px;
    }
    .header {
      display: flex;
      align-items: baseline;
      justify-content: space-between;
      gap: 12px;
      padding: 10px 6px;
    }
    h1 {
      margin: 0;
      font-size: 18px;
      letter-spacing: .2px;
    }
    .hint { color: var(--muted); font-size: 13px; }
    .card {
      background: linear-gradient(180deg, rgba(255,255,255,.03), rgba(255,255,255,.015));
      border: 1px solid var(--border);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow: hidden;
    }
    .card-inner { padding: 16px; }
    .controls {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 12px;
      align-items: end;
    }
    .field label {
      display: block;
      font-size: 12px;
      color: var(--muted);
      margin-bottom: 6px;
    }
    input[type="number"] {
      width: 100%;
      padding: 12px 12px;
      border-radius: 12px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.25);
      color: var(--text);
      font-size: 15px;
      outline: none;
    }
    input[type="number"]:focus { border-color: rgba(255,106,61,.5); box-shadow: 0 0 0 4px rgba(255,106,61,.12); }
    .btns { display: flex; gap: 10px; }
    button {
      appearance: none;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding: 12px 14px;
      border-radius: 12px;
      font-weight: 600;
      cursor: pointer;
      transition: transform .05s ease, border-color .15s ease, background .15s ease;
      white-space: nowrap;
    }
    button.primary {
      border-color: rgba(255,106,61,.55);
      background: rgba(255,106,61,.12);
    }
    button:active { transform: translateY(1px); }
    .toggles {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 12px;
    }
    .toggle {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.18);
      user-select: none;
    }
    .toggle input { transform: translateY(1px); }
    

.keypad {
  margin-top: 14px;
  display: grid;
  grid-template-columns: repeat(3, 1fr);
  gap: 10px;
}
.keypad button {
  padding: 12px 0;
  border-radius: 14px;
  font-size: 16px;
  font-weight: 800;
  background: rgba(255,255,255,.04);
  border: 1px solid var(--border);
  color: var(--text);
  cursor: pointer;
  transition: transform .05s ease, border-color .15s ease, background .15s ease;
}
.keypad button:active { transform: translateY(1px); }
.keypad button.wide { grid-column: span 1; }
.keypad button.primary {
  border-color: rgba(255,106,61,.55);
  background: rgba(255,106,61,.12);
}

/* Hit alert */
.hit-flash{
  position: fixed;
  inset: 0;
  /* warmer + stronger "fire" */
  background: radial-gradient(900px 600px at 15% 10%, rgba(255,106,61,.38), transparent 60%),
              radial-gradient(800px 520px at 85% 30%, rgba(255,138,61,.22), transparent 55%),
              rgba(255,106,61,.20);
  opacity: 0;
  pointer-events: none;
  z-index: 999;
}
.hit-log{
  position: fixed;
  top: 14px;
  right: 14px;
  z-index: 1000;
  pointer-events: none;
  display: flex;
  flex-direction: column;
  gap: 8px;
  align-items: flex-end;
  max-height: 60vh;
  overflow: hidden;
}
.hit-item{
  font-family: var(--mono);
  font-weight: 900;
  letter-spacing: .5px;
  padding: 10px 12px;
  border-radius: 14px;
  border: 1px solid rgba(255,106,61,.70);
  background: rgba(0,0,0,.38);
  box-shadow: var(--shadow);
  min-width: 54px;
  text-align: center;
  opacity: 1;
}
.hit-item.new{
  animation: hitItem 1400ms ease-in-out 1;
}
.hit-log .hit-item:nth-child(n+5){
  opacity: .72;
}
body.hit-alert .hit-flash{
  animation: hitFlash 1600ms ease-out 1;
}
@keyframes hitFlash{
  0%{ opacity: 0; }
  10%{ opacity: 1; }
  55%{ opacity: .80; }
  100%{ opacity: 0; }
}
@keyframes hitItem{
  0%{ transform: translateY(-10px) scale(.96); filter: brightness(1); }
  18%{ transform: translateY(0) scale(1.06); filter: brightness(1.35); }
  55%{ transform: translateY(0) scale(1.02); filter: brightness(1.15); }
  100%{ transform: translateY(0) scale(1); filter: brightness(1); }
}

.out {
      display: grid;
      gap: 10px;
      padding: 14px 16px 18px;
      border-top: 1px solid var(--border);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: 8px;
      padding: 14px;
      border-radius: 14px;
      border: 1px solid var(--border);
      background: rgba(0,0,0,.16);
    }
    .tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      font-weight: 700;
      letter-spacing: .2px;
    }
    .tag .emoji { font-size: 16px; }
    .tag .label { font-size: 13px; color: var(--muted); font-weight: 600; }
    .nums {
      font-family: var(--mono);
      font-size: 16px;
      letter-spacing: .4px;
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
    }
    .pill {
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid var(--border);
      background: rgba(255,255,255,.03);
      min-width: 44px;
      text-align: center;
    }
    .pill.fire { border-color: rgba(255,106,61,.40); }
    .pill.ok { border-color: rgba(57,217,138,.40); }
    .meta {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
      color: var(--muted);
      font-size: 13px;
    }
    .meta code {
      font-family: var(--mono);
      background: rgba(255,255,255,.03);
      border: 1px solid var(--border);
      padding: 2px 6px;
      border-radius: 8px;
      color: var(--text);
      font-size: 12px;
    }
    .error {
      color: #ffb4a2;
      border-color: rgba(255,180,162,.35) !important;
      background: rgba(255,180,162,.08) !important;
    }
    .footer {
      padding: 12px 16px;
      border-top: 1px solid var(--border);
      color: var(--muted);
      font-size: 12px;
      line-height: 1.4;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="header">
      <h1>Roulette Block-Jump Tool</h1>
      <div class="hint">Mode A = automatic blocks ‚Ä¢ Mode B = optional neighbors</div>
    </div>

    <div class="card">
      <div class="card-inner">
        <div class="controls">
          <div class="field">
            <label for="hit">Last hit number (0‚Äì36)</label>
            <input id="hit" type="number" inputmode="numeric" min="0" max="36" step="1" placeholder="e.g., 17" />
          </div>
          <div class="btns">
            <button id="undoHitBtn" title="Undo last committed hit">Undo hit</button>
            <button id="resetBtn" class="primary" title="Reset everything (predictions + hit log)">Reset</button>
          </div>
        </div>

        <div class="toggles">
          <label class="toggle">
            <input id="modeB" type="checkbox" />
            <span><strong>Mode B</strong> (¬±1 neighbors)</span>
          </label>
        </div>

        <div class="meta" id="meta"></div>

        <div class="keypad" id="keypad" aria-label="Number keypad">
          <button type="button" data-k="1">1</button>
          <button type="button" data-k="2">2</button>
          <button type="button" data-k="3">3</button>
          <button type="button" data-k="4">4</button>
          <button type="button" data-k="5">5</button>
          <button type="button" data-k="6">6</button>
          <button type="button" data-k="7">7</button>
          <button type="button" data-k="8">8</button>
          <button type="button" data-k="9">9</button>
          <button type="button" data-k="0" class="wide">0</button>
          <button type="button" data-k="back" title="Backspace">‚å´</button>
          <button type="button" data-k="undoHit" class="primary" title="Undo last hit">‚Ü©Ô∏é</button>
        </div>

      </div>

      <div class="out" id="out">
        <div class="row">
          <div class="tag"><span class="emoji">üéØ</span> <span>Enter a number ‚Äî results update automatically</span></div>
          <div class="hint">We‚Äôll output two target blocks in the other two dozens. If Mode B is on, we expand each block by ¬±1 (clamped to 1‚Äì36).</div>
        </div>
      </div>

      <div class="footer">
        <strong>Logic:</strong> Split each dozen into 4 blocks of 3 (1‚Äì3, 4‚Äì6, 7‚Äì9, 10‚Äì12). When a hit lands in a block, output the <em>same block index</em> in the other two dozens.
        <br/>
        <strong>Note:</strong> 0 has no dozen/block ‚Üí shown as RESET.
      </div>
    </div>
  </div>

  
  <div class="hit-flash" id="hitFlash" aria-hidden="true"></div>
  <div class="hit-log" id="hitLog" aria-hidden="true"></div>


  <script>
    const hitEl = document.getElementById("hit");
    const modeBEl = document.getElementById("modeB");
    const outEl = document.getElementById("out");
    const metaEl = document.getElementById("meta");
    const undoHitBtn = document.getElementById("undoHitBtn");
    const resetBtn = document.getElementById("resetBtn");
    const keypad = document.getElementById("keypad");

    // Auto-commit behavior: when a valid hit (0‚Äì36) is entered and input pauses briefly,
    // we "commit" the spin: render results, store prediction set, then clear the input for the next hit.
    let commitTimer = null;
    let suppressInput = false;

    function clamp(n, lo, hi) { return Math.max(lo, Math.min(hi, n)); }

    function getDozenStart(dozen) {
      if (dozen === 1) return 1;
      if (dozen === 2) return 13;
      if (dozen === 3) return 25;
      return null;
    }

    function getDozen(n) {
      if (n >= 1 && n <= 12) return 1;
      if (n >= 13 && n <= 24) return 2;
      if (n >= 25 && n <= 36) return 3;
      return null; // includes 0 or invalid
    }

    function getBlockIndex(n) {
      // block within its dozen: 1..4
      const pos = ((n - 1) % 12) + 1; // 1..12
      return Math.ceil(pos / 3);      // 1..4
    }

    function makeBlock(dozen, blockIndex) {
      const start = getDozenStart(dozen);
      const offset = (blockIndex - 1) * 3;
      const a = start + offset;
      return [a, a + 1, a + 2];
    }

    function expandBlock(block) {
      const a = block[0], c = block[2];
      const lo = clamp(a - 1, 1, 36);
      const hi = clamp(c + 1, 1, 36);
      const arr = [];
      for (let i = lo; i <= hi; i++) arr.push(i);
      return arr;
    }

    function pills(nums, kind) {
      return nums.map(n => `<span class="pill ${kind}">${n}</span>`).join("");
    }

    function renderRow(kindEmoji, title, dozenLabel, nums, kindClass) {
      return `
        <div class="row">
          <div class="tag">
            <span class="emoji">${kindEmoji}</span>
            <span>${title} <span class="label">${dozenLabel}</span></span>
          </div>
          <div class="nums">${pills(nums, kindClass)}</div>
        </div>
      `;
    }

    function renderError(msg) {
      outEl.innerHTML = `
        <div class="row error">
          <div class="tag"><span class="emoji">‚ö†Ô∏è</span> <span>Input error</span></div>
          <div>${msg}</div>
        </div>
      `;
      metaEl.textContent = "";
    }

    function renderReset() {
      predHistory.length = 0;
      outEl.innerHTML = `
        <div class="row">
          <div class="tag"><span class="emoji">üåÄ</span> <span>Hit was <strong>0</strong> ‚Üí <span class="label">RESET</span></span></div>
          <div class="hint">0 has no dozen/block. Practical play: ignore this spin for the tool and restart from the next non-zero hit.</div>
        </div>
      `;
      metaEl.innerHTML = `<span>Dozen: <code>none</code></span> <span>Block: <code>none</code></span>`;
    }


// input history for Undo
let lastValue = "";


// prediction history (last 3 sets) for hit alerts
const predHistory = []; // Array<Set<number>>

const hitFlashEl = document.getElementById("hitFlash");
const hitLogEl = document.getElementById("hitLog");
const keypadEl = document.getElementById("keypad");

function pushPredictionSet(nums){
  const set = new Set(nums);
  if (set.size === 0) return;
  predHistory.unshift(set);
  if (predHistory.length > 3) predHistory.length = 3;
}

function wasPredicted(n){
  for (const s of predHistory){
    if (s.has(n)) return true;
  }
  return false;
}

let hitAlertTimer = null;
function showHitAlert(n){
  // Screen flash
  document.body.classList.remove("hit-alert");
  void document.body.offsetWidth;
  document.body.classList.add("hit-alert");
  clearTimeout(hitAlertTimer);
  hitAlertTimer = setTimeout(() => {
    document.body.classList.remove("hit-alert");
  }, 1650);

  // Persistent hit log (top-right)
  const item = document.createElement("div");
  item.className = "hit-item new";
  item.textContent = String(n);
  hitLogEl.prepend(item);

  // remove the 'new' animation class after it plays (keeps the item visible)
  setTimeout(() => item.classList.remove("new"), 1500);

  // keep list tidy
  const maxItems = 10;
  while (hitLogEl.children.length > maxItems) {
    hitLogEl.removeChild(hitLogEl.lastElementChild);
  }
}
function renderInitial() {
  outEl.innerHTML = `
    <div class="row">
      <div class="tag"><span class="emoji">üéØ</span> <span>Enter a number ‚Äî <span class="label">auto-calc</span></span></div>
      <div class="hint">Mode A outputs two blocks in the other two dozens. Mode B expands each block by ¬±1 (clamped to 1‚Äì36).</div>
    </div>
  `;
  metaEl.textContent = "";
}

function setHitValue(val) {
  hitEl.value = val;
  lastValue = val;
}

// Committed state history (for Undo hit)
const stateHistory = [];

function clonePredHistory() {
  // predHistory is Array<Set<number>>. Clone into plain arrays for safe snapshotting.
  return predHistory.map(s => Array.from(s));
}

function snapshotState() {
  return {
    outHTML: outEl.innerHTML,
    metaHTML: metaEl.innerHTML,
    modeB: modeBEl.checked,
    pred: clonePredHistory(),
    hitLogHTML: hitLogEl.innerHTML
  };
}

function restoreState(snap) {
  outEl.innerHTML = snap.outHTML;
  metaEl.innerHTML = snap.metaHTML;
  modeBEl.checked = snap.modeB;

  predHistory.length = 0;
  // snap.pred is Array<number[]>
  snap.pred.forEach(arr => predHistory.push(new Set(arr)));

  hitLogEl.innerHTML = snap.hitLogHTML;

  // clear any visual alert + pending commit
  document.body.classList.remove("hit-alert");
  if (commitTimer) { clearTimeout(commitTimer); commitTimer = null; }

  suppressInput = true;
  hitEl.value = "";
  lastValue = "";
  setTimeout(() => { suppressInput = false; hitEl.focus(); }, 0);
}

function undoLastHit() {
  if (stateHistory.length <= 1) return; // keep initial state
  stateHistory.pop(); // discard current state
  restoreState(stateHistory[stateHistory.length - 1]);
}

function resetAll() {
  predHistory.length = 0;
  hitLogEl.innerHTML = "";
  modeBEl.checked = false;
  metaEl.textContent = "";
  renderInitial();

  stateHistory.length = 0;
  stateHistory.push(snapshotState());

  suppressInput = true;
  hitEl.value = "";
  lastValue = "";
  if (commitTimer) { clearTimeout(commitTimer); commitTimer = null; }
  setTimeout(() => { suppressInput = false; hitEl.focus(); }, 0);
}

function calculate(fromUserInput = true) {
      const raw = hitEl.value.trim();
      if (raw === "") return renderInitial();

      const n = Number(raw);
      if (!Number.isInteger(n) || n < 0 || n > 36) {
        return renderError("Please enter a whole number between <strong>0</strong> and <strong>36</strong>.");
      }

      if (n === 0) { predHistory.length = 0; return renderReset(); }

      // HIT ALERT: if the current number was inside any of the last 3 prediction sets
      if (fromUserInput && predHistory.length && wasPredicted(n)) {
        showHitAlert(n);
      }


      const dozen = getDozen(n);
      const blockIndex = getBlockIndex(n);

      // determine target dozens (the other two)
      const targetDozens = [1,2,3].filter(d => d !== dozen);

      const blockA = makeBlock(targetDozens[0], blockIndex);
      const blockB = makeBlock(targetDozens[1], blockIndex);

      metaEl.innerHTML = `
        <span>Hit: <code>${n}</code></span>
        <span>Dozen: <code>${dozen}${dozen===1?"st":dozen===2?"nd":"rd"}</code></span>
        <span>Block: <code>${blockIndex}</code> (<code>${makeBlock(dozen, blockIndex).join(" ")}</code>)</span>
      `;

      const modeB = modeBEl.checked;

      // Save this spin's prediction set (for the next inputs). Mode A always included.
      const predictedNums = [...blockA, ...blockB];
      if (modeB) {
        predictedNums.push(...expandBlock(blockA), ...expandBlock(blockB));
      }
      // de-dupe
      const uniq = Array.from(new Set(predictedNums));
      pushPredictionSet(uniq);


      let html = "";
      // Mode A (always)
      html += renderRow("üî•", blockA.join(" "), `(${targetDozens[0]}${targetDozens[0]===1?"st":targetDozens[0]===2?"nd":"rd"} dozen)`, blockA, "fire");
      html += renderRow("üî•", blockB.join(" "), `(${targetDozens[1]}${targetDozens[1]===1?"st":targetDozens[1]===2?"nd":"rd"} dozen)`, blockB, "fire");

      // Mode B (optional)
      if (modeB) {
        const exA = expandBlock(blockA);
        const exB = expandBlock(blockB);
        html += renderRow("‚úÖ", exA.join(" "), `(Mode B)`, exA, "ok");
        html += renderRow("‚úÖ", exB.join(" "), `(Mode B)`, exB, "ok");
      }

      outEl.innerHTML = html;
    }

    
    function isValidHitValue(raw){
      if (raw === "") return false;
      const n = Number(raw);
      return Number.isInteger(n) && n >= 0 && n <= 36;
    }

    
function scheduleCommit(){
  if (suppressInput) return;
  if (commitTimer) clearTimeout(commitTimer);

  const raw = hitEl.value.trim();
  if (!isValidHitValue(raw)) return;

  // Smart auto-commit:
  // - If user enters 2 digits, commit quickly.
  // - If user enters 1 digit that COULD start a valid 2-digit roulette number (1,2,3),
  //   wait longer to allow the second digit.
  // - Otherwise commit fast.
  const commitAfterMs = (() => {
    // Feels instant, but still allows double-digit entry.
    // - 2 digits: commit almost immediately.
    // - first digit 1/2/3: brief grace period for a second digit.
    // - otherwise: quick commit.
    if (raw.length >= 2) return 90;
    const d = raw[0];
    if (d === "1" || d === "2" || d === "3") return 900;
    return 380;
  })();

  commitTimer = setTimeout(() => {
    if (suppressInput) return;
    const nowRaw = hitEl.value.trim();
    if (nowRaw === raw && isValidHitValue(nowRaw)) {
      commitHit();
    }
  }, commitAfterMs);
}

    function commitHit(){
      const raw = hitEl.value.trim();
      if (!isValidHitValue(raw)) return;
      // Render + store predictions + alert checks happen inside calculate()
      calculate(true);
      // Save committed state (for Undo hit)
      stateHistory.push(snapshotState());

      // Prepare for next entry: clear only the input (keep results visible)
      suppressInput = true;
      hitEl.value = "";
      lastValue = "";      if (commitTimer) { clearTimeout(commitTimer); commitTimer = null; }
      // allow the DOM to process the value change without re-triggering logic
      setTimeout(() => { suppressInput = false; hitEl.focus(); }, 0);
    }


    undoHitBtn.addEventListener("click", undoLastHit);
    resetBtn.addEventListener("click", resetAll);

    // commit when the user finishes entering a valid hit (debounced)
    hitEl.addEventListener("input", () => {
      if (suppressInput) return;
      const v = hitEl.value;
      lastValue = v;
      // If the user clears the input while typing, keep the last results on screen.
      if (v.trim() === "") return;
      scheduleCommit();
    });

modeBEl.addEventListener("change", () => {
      if (suppressInput) return;
      if (hitEl.value.trim() === "") return; // next commit will use the chosen mode
      scheduleCommit();
    });

// keypad support (0‚Äì9, backspace, undo)
    keypad.addEventListener("click", (e) => {
      const btn = e.target.closest("button");
      if (!btn) return;
      const k = btn.dataset.k;

      if (k === "back") {
        setHitValue(hitEl.value.slice(0, -1));
      } else if (k === "undoHit") {
        return undoLastHit();
      } else {
        const next = (hitEl.value + k).replace(/^0+(?=\d)/, "");
        let clamped = next;
        const n = Number(next);
        if (Number.isFinite(n) && n > 36) clamped = "36";
        setHitValue(clamped);
      }

      if (hitEl.value.trim() !== "") scheduleCommit();
      hitEl.focus();
    });

    // nice default focus
    hitEl.focus();
    renderInitial();
    stateHistory.push(snapshotState());
  </script>
</body>
</html>
